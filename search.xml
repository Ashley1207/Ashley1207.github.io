<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java容器</title>
    <url>/2020/07/05/java%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>最近准备找实习刷力扣的时候总是会碰到各种各样的java容器，所以在网上找了很多的资料复习了一下java这个基础的知识点。写到博客里防止自己再次混淆。</p>
<h1 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h1><p><strong>Iterable</strong>   ：迭代器接口，用于遍历数据。</p>
<p><strong>Collection</strong>：集合，java容器的大部分集合的父类接口。java集合分两种，一种是Collection（只存储值的容器），一种是map（存储键值对的容器）</p>
<p><strong>List</strong> ：顺序写数据的数组容器，内存连续</p>
<p><strong>Queue</strong> ：先进先出队列，入队出队操作都有两种实现，一种失败抛出异常，一种返回null或者fasle，不能写入null</p>
<p><strong>Deque</strong> ：继承Queue，双端队列，不再是先进先出，前后两端都可以插入和删除，不能从中间插入，不能写入null</p>
<p><strong>Set</strong> ：用于存放非重复元素的集合，可以插入null</p>
<p><strong>SortedSet</strong> ：支持排序的set集合（set使用的hash存储，默认的是不支持排序）</p>
<p><strong>NavigableSet</strong> ：提供有序集合的扩展功能，如返回大于、大于等于、小于、小于等于某个key的子集合等。</p>
<h1 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h1><h2 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h2><p><strong>Stack</strong>   ：栈，先进后出，数组</p>
<p><strong>ArrayList</strong> ：有序数组，基于动态数组实现，支持随机访问</p>
<p><strong>LinkedList</strong> ：基于双向链表实现，只能顺序访问，但可以快速的在链表中间插入和删除元素</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><strong>LinkedList</strong> ：支持双向队列</p>
<p><strong>ArrayQueue</strong> ：使用数组实现队列</p>
<p><strong>PriorityQueue</strong> ：优先级队列，基于堆实现</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><strong>LinkedList</strong>  </p>
<p><strong>ArrayQueue</strong>    </p>
<p><strong>ArrayDeque</strong> ：依赖可变循环数组，没有容量限制，可根据需求自动扩容，不支持值为null的元素</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>HashSet</strong> ：基于哈希实现，支持快速查找，但不支持有序操作</p>
<p><strong>LinkedHashSet</strong> :有序的hashset，具有hashset的查找效率，内部使用链表</p>
<p><strong>TreeSet</strong> ：支持排序的hashset，基于红黑树实现，查找效率不如hashset</p>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p><strong>TreeSet</strong> </p>
<p><img src="/2020/07/05/java%E5%AE%B9%E5%99%A8/image-20200705233733985.png" alt="image-20200705233311885"></p>
<p>图片截图来源：<a href="https://www.cnblogs.com/gc65/p/11220822.html" target="_blank" rel="noopener">https://www.cnblogs.com/gc65/p/11220822.html</a></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><strong>HashMap</strong> :基于哈希实现</p>
<p><strong>HashTable</strong> ：线程安全，与hashmap类似</p>
<p><strong>LinkedHashMap</strong> ：继承HashMap使用链表维护元素的顺序，hashmap是无需的，LinkedHashMap是有序的存储元素</p>
<p><strong>TreeMap</strong> ：基于红黑树实现，TreeMap中的元素默认按照keys的自然排序排序</p>
<p><strong>注意</strong> ：hashmap可实现快速存储和检索，但其缺点是包含的元素是无序的，这导致它在大量迭代的情况下表现不佳</p>
<p>LinkedHashMap保留了HashMap的优势，且包含的元素是有序的，它在大量迭代的情况下会表现更好</p>
<p>TreeMap能便捷的实现对其内部元素的各种排序，但其一般性能比前两种map差。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 容器</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2020/04/27/zyqfirstBlog/</url>
    <content><![CDATA[<p>首次使用hexo出现的错误—-报空格错误<br><img src="/2020/04/27/zyqfirstBlog/2020-05-02-15-30-33.png" alt><br>原因是自己最上面加了注释，才导致博客一直发布不了，搞的自己差点放弃,好在结局是好的，搞了两天总算是把自己的博客给搭建好了，很开心，还专门买了一个域名玩玩。</p>
<p>本次搭建hexo博客主要是参考<a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a>，修改了主题，加入了访问量，但是评论还没加，等有时间再搞吧。</p>
<p>购买了阿里的域名，9块钱一年的，还挺便宜，域名的设置是参考<a href="https://www.jianshu.com/p/1dc893a05234" target="_blank" rel="noopener">https://www.jianshu.com/p/1dc893a05234</a>以及<a href="https://blog.csdn.net/mqdxiaoxiao/article/details/92799543" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/92799543</a><br>唯一的缺点就是访问有点慢<br>另外编写markdown使用的是vscode，paste Image真是一个超好用的插件，我用quiver写markdown时图片可以直接复制粘贴，这个插件也实现了这个功能</p>
<p>好吧，后来又出现了一个图片显示不出来的bug，下载<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a>,<br>然后将配置里面的<strong>post_asset_folder: true</strong>改成这样就可以了</p>
<p>我就奇了怪了，我自己手动建立的文件夹不能部署到github上，因为我想把图片单纯的存在一个文件夹里，但这样就不行</p>
]]></content>
      <tags>
        <tag>hexo-bug</tag>
      </tags>
  </entry>
  <entry>
    <title>java字符和字符串</title>
    <url>/2020/07/11/java%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>‘  ‘ 单引号表示单个字符</p>
<p>“   ”双引号表示字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>字符和字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/05/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="基本思想–减而治之"><a href="#基本思想–减而治之" class="headerlink" title="基本思想–减而治之"></a>基本思想–减而治之</h4><p>这里「减」是「减少问题」规模的意思，治是「解决」的意思。「减治思想」从另一个角度说，是「排除法」，意即：每一轮排除掉一定不存在目标元素的区间，在剩下 可能 存在目标元素的区间里继续查找。每一次我们通过一些判断和操作，使得问题的规模逐渐减少。又由于问题的规模是有限的，我们通过有限次的操作，一定可以解决这个问题。</p>
<h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><ol>
<li>在二分数组里进行查找一个数—-二分下标</li>
<li>在整数范围里查找一个整数—二分答案</li>
</ol>
<h4 id="两种思路"><a href="#两种思路" class="headerlink" title="两种思路"></a>两种思路</h4><ol>
<li><p>在循环体查找元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 目标元素可能存在在区间 [left, right]</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="comment">// 推荐的写法是 int mid = left + (right - left) / 2;</span></span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               <span class="comment">// 目标元素可能存在在区间 [mid + 1, right]</span></span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 目标元素可能存在在区间 [left, mid - 1]</span></span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   <strong>细节</strong>：</p>
<ol>
<li><p>while (left &lt;= right)  表示在区间里只剩下一个元素的时候，我们还需要继续查找，因此循环可以继续的条件是 left&lt;=right </p>
</li>
<li><p>取中间数的代码int mid = (left + right) / 2 可能会在成整型溢出，推荐</p>
<p>​               int mid = left + (right - left) / 2;</p>
</li>
</ol>
<ol start="2">
<li>在循环体中排除目标元素一定不存在的区间</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 目标元素可能存在在区间 [left, right]</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">         <span class="comment">//向下取整</span></span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               <span class="comment">// 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 下一轮搜索区间是 [left, mid]</span></span><br><span class="line">               right = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">           <span class="keyword">return</span> left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="comment">//向上取整</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid, right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>细节</strong>：</p>
<ol>
<li><p>while (left &lt; right)  表示退出循环的时候只剩下一个元素</p>
</li>
<li><p>在循环体内考虑如何缩减待搜索区间，也就是在待搜索区间内排除一定不存在目标元素的区间</p>
</li>
<li><p>根据中间数被分到左边和右边区间，来调整中间数的行为</p>
</li>
<li><p>如何缩小待搜索的区间，一个有效的办法：从nums[mid] 满足什么条件的时候一定不是目标元素去考虑，进而考虑mid 的左边元素和右边元素哪一边可能存在目标元素，一个结论是：当看到left==mid的时候，取中间数需要向上取整，这一点是为了避免死循环</p>
</li>
<li><p>退出循环的时候，根题意看是否需要单独判断最后剩下的那个数是不是目标元素</p>
</li>
<li><p>边界设置的两种写法：</p>
<p>right = mid 和 left = mid + 1 和 int mid = left + (right - left) / 2; 一定是配对出现的；<br>right = mid - 1 和 left = mid 和 int mid = left + (right - left + 1) / 2; 一定是配对出现的。</p>
</li>
</ol>
<p><strong>使用范围：</strong></p>
<p>适合于查找边界问题</p>
<p><strong>对于以上两种思路：</strong></p>
<p><strong>如果这个二分查找的问题比较简单，在输入数组里不同元素的个数只有一个，使用第一种</strong></p>
<p><strong>如果这个二分查找的问题比较复杂，要你找一个可能在数组里不存在，或者找边界这样的问题，使用第二种，在循环体内排除一定不存在目标元素的区间会比较简单一些。</strong></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2021/04/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度是一个函数，它定性来描述该算法的运行时间。</p>
<p>那么该如何估算程序的运行时间呢，通常会估算算法的操作单元数来代表程序的消耗时间。这里默认CPU的每个单元运行消耗的时间都是相同的。</p>
<p>假设算法的时间规模是n，那么 操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作做算法的渐进时间复杂，简称时间复杂度</p>
<h3 id="什么是大O"><a href="#什么是大O" class="headerlink" title="什么是大O"></a>什么是大O</h3><p>算法导论给出的解释：<strong>大O是用来表示上界的</strong>。当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。</p>
<p>同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是O(n^2) 。</p>
<p>输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是O(n)，但如果数据是逆序的话，插入排序的时间复杂度就是O(n^2)，也就对于所有输入情况来说，最坏是O(n^2) 的时间复杂度，所以称插入排序的时间复杂度为O(n^2)。</p>
<p>同样的同理再看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，<strong>「所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)」</strong>。</p>
<p><strong>「但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界</strong></p>
<p>我们主要关心的还是一般情况下的数据形式。</p>
<p><strong>「面试中说道算法的时间复杂度是多少指的都是一般情况」</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p>
<h3 id="不同数据规模的差异"><a href="#不同数据规模的差异" class="headerlink" title="不同数据规模的差异"></a>不同数据规模的差异</h3><p><img src="/2021/04/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409145616758.png" alt="image-20210409145616758"></p>
<p>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）。</p>
<p>就像上图中 O(5n^2) 和 O(100n) 在n为20之前 很明显 O(5n^2)是更优的，所花费的时间也是最少的。</p>
<p>那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说O(100n) 就是O(n)的时间复杂度，O(5n^2) 就是O(n^2)的时间复杂度，而且要默认O(n) 优于O(n^2) 呢 ？</p>
<p>这里就又涉及到大O的定义，<strong>「因为大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量」</strong>。</p>
<p>例如上图中20就是那个点，n只要大于20 常数项系数已经不起决定性作用了。</p>
<p><strong>「所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示」</strong>：</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)(立方阶) &lt; O(2^n) (指数阶)</p>
<p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了。</p>
<h3 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h3><ol>
<li><p>对于一个循环体，假设循环体的时间复杂度为O(n),循环次数为 m，则这个<br>循环的时间复杂度为 O(n×m)。<img src="/2021/04/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409153656308.png" alt="image-20210409153656308"></p>
<p>此时时间复杂度为 O(n × 1)，即 O(n)。</p>
</li>
<li><p>对于多个循环体，假设循环体的时间复杂度为O(n)，各个循环的循环次数分别为a,b,c。。。。，则这个循环的时间复杂度为O(n<em>a</em>b<em>c</em>…..),此时时间复杂度为 O(n × n × 1)，即 O(n^2)。</p>
<p><img src="/2021/04/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409153832353.png" alt="image-20210409153832353"></p>
</li>
<li><p>对于顺序执行的语句或者算法，总的时间复杂度 等于其中最大的时间复杂度<img src="/2021/04/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409154224821.png" alt="image-20210409154224821"></p>
<p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p>
</li>
<li><p>对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。<img src="/2021/04/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409154258121.png" alt="image-20210409154258121"></p>
</li>
</ol>
<p>​       此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p>
<ol start="5">
<li>递归复杂度计算</li>
</ol>
<p>参考：<a href="https://mp.weixin.qq.com/s/I6ZXFbw09NR31F5CJR_geQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/I6ZXFbw09NR31F5CJR_geQ</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>字符和字符串加法</title>
    <url>/2020/07/11/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<p><strong>加法运算特点</strong></p>
<ol>
<li><p>加法两边是数值型数据时，进行加法运算</p>
</li>
<li><p>加法两边有任意一边是字符串时，进行字符串的拼接</p>
</li>
<li><p>字符型数据参与算术运算，是用字符在计算机中存储的数据来进行运算的</p>
<p>‘0’——48</p>
<p>‘a’——97</p>
<p>‘A’——-65</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> b=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> c=(<span class="keyword">byte</span>)(a+b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="keyword">char</span> d=<span class="string">'a'</span>;</span><br><span class="line">        System.out.println(a+d);</span><br><span class="line">        System.out.println(<span class="string">"helloword"</span>+<span class="number">10</span>+<span class="number">20</span>);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>输出结果：</p>
<p><img src="/2020/07/11/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95/image-20200711103245195.png" alt="image-20200711103245195"></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>字符和字符串加法</tag>
      </tags>
  </entry>
  <entry>
    <title>实习一个月总结</title>
    <url>/2020/09/17/%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%9C%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>从八月十九号入职爱奇艺会员业务部门成为一名java开发实习生，到今天为止差不多快一个月了。从刚开始的熟悉代码画流程图，到实习业务之后开始写Python脚本，接触项目，开发监控系统和管理数据系统，每一项对我来说都是陌生和全新的，有的时候忙到一天没时间吃饭，有的时候轻松到一天都可以看文档学习。偶尔也会有担心，担心自己写不出来代码，担心自己写出来代码后又被批评代码写的太垃圾，后来安慰自己本来到这里就是来学习的，如果我一开始我就杨洋做的很好，那么我到这里的意义在哪里呢？我的目标是来学习，把他们的本领学到手，而不倒任务完成的有多漂亮，工作做的有多好。偶尔反思自己，我需要摆正自己的心态，认清自己的不足，不会的就多学习，不能怕丢脸，自己本来就是一个菜鸟，想成为大神，想明年进入理想的公司，这些都是必经之路。</p>
<p>入职一个月，我学到的最重要的就是书的重要性，多看书，多看代码。我的mentor现在还每天都看书来充实自己，而我最为一个研究生，又有多久没有碰过书了，惭愧惭愧。尤其昨天开会的时候，有一些问题我没有答上来，但其实我是知道的，让我了解我需要书来充实自己，也让我了解到mentor的知识面。了解到自己的不足，就有努力的方向，昨天的遗憾留给昨天，今天明天继续努力。</p>
<p>多刷题，多看书，多写代码，多学习！！！！</p>
<p>加油！！！！奥利给！！！！</p>
]]></content>
      <categories>
        <category>唠叨</category>
      </categories>
      <tags>
        <tag>无聊琐事</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/03/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2020/07/13/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><strong>多态</strong>：多种状态，同一对象在不同情况下表现出不同的状态或行为<br>       <strong>实现多态的步骤：</strong><br>  要有继承或实现的关系<br>  是要方法重写<br>  父类引用指向子类对象（is a关系）</p>
<p><strong>多态的好处：</strong><br>基于继承关系，只需要维护父类的代码，提高了代码的复用性，大大降低了维护程序的工作量<br>可扩展性：把不同的子类对象都当做父类看待，屏蔽了不同子类对象间的差异<br>做出通用的代码，以适应不同的需求，实现了向后兼容</p>
<p><strong>多态的弊端：</strong>不能使用子类特有的对象</p>
<p><strong>类型转换：</strong>当需要使用子类特有的功能时，需要进行类型转换<br><strong>向上转型（自动类型转换）：</strong><br>         子类型转换为父类型<br>         Animal an=new Dog()<br><strong>向下转型（强制类型转换）：</strong><br>         父类型转换成子类型<br>         Dog dog=(Dog)animal;<br><strong>注意：</strong><br>   只能在继承层次内进行转换<br>   将父类对象转换成子类之前，使用Instanceof进行检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*结论：</span></span><br><span class="line"><span class="comment">        多态中调用成员方法是编译看左（左边的类型有没有这个成员）</span></span><br><span class="line"><span class="comment">        运行看右（运行时具体用的是右类中的该成员） </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Dog dog=<span class="keyword">new</span> Dog();</span><br><span class="line">        Animal mouse=<span class="keyword">new</span> Mouse();</span><br><span class="line">        mouse.setName(<span class="string">"老鼠"</span>);</span><br><span class="line">        <span class="comment">//mouse.eat();</span></span><br><span class="line">        showAnimal(mouse);</span><br><span class="line">        dog.setName(<span class="string">"狗"</span>);</span><br><span class="line">        <span class="comment">//animal.eat();//调用子类的方法，因为父类eat方法被覆盖重写了</span></span><br><span class="line">        showAnimal(dog);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* public static void showAnimal(Mouse mouse)&#123;</span></span><br><span class="line"><span class="comment">        mouse.eat();</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="comment">//多态的使用场景，父类型可以作为形参的数据类型，</span></span><br><span class="line">    <span class="comment">//这样可以接受其任意子类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试多态关系中，成员变量的使用</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">多态关系中，成员变量是不涉及到重写的</span></span><br><span class="line"><span class="comment">多态关系中，使用成员变量，遵循  编译看左（编译期间看有没有这个类型），</span></span><br><span class="line"><span class="comment">运行看左（在运行的期间，使用的是左边的类型中的这个成员）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnimal1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal1 an=<span class="keyword">new</span> Dog1();</span><br><span class="line">        System.out.println(an.name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p><strong>final关键字：</strong><br>final的作用：<br>修饰方法：该方法不能被重写<br>         不能与abstract共存<br>修饰变量：最终变量，即常量，只能赋值一次<br>        不建议修饰引用类型数据，因为仍然可以通过引用修改对象的内部数据，意义不大<br>修饰类：不能被继承,但是可以继承其他的类</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>概念：</strong><br>接口技术用于描述类具有什么功能，但并不给出具体实现，<br>类要遵循从接口描述的同意规则进行定义，所以，接口是对外提供的一组规则，标准<br><strong>接口的定义：</strong><br>定义接口使用关键字interface<br>         interface 接口名 {}<br><strong>类和接口是实现关系，用implements表示</strong><br>        class  类名 implements 接口名<br><strong>接口创建对象的特点：</strong><br>接口不能实例化：通过多态的方式实例化子类对象<br>接口的子类（实现类）：可以是抽象类，不用重写接口中的抽象方法，也可以是普通类，必须重写接口中的抽象方法<br><strong>接口继承关系的特点：</strong><br><strong>接口与接口之间的关系：</strong><br><strong>继承关系，可以是多继承</strong><br><strong>继承和实现的区别：</strong><br>继承体现的是 is a 的关系，父类中定义共性内容<br>实现体现的是like a的关系，接口中定义扩展功能，不能写到父类中，写到接口中，谁具有这个功能，谁去实现</p>
<p><strong>接口和类之间的关系：</strong><br>类与类之间：继承关系，只能单继承，不能多继承，单可以多层继承<br>类与接口之间：实现关系，可以单实现，可以多实现<br>接口与接口：可以单继承，可以多继承</p>
<p><strong>总结：</strong>对于一个类来说，它的父类中定义的都是共性内容<br>                  对于一个类来讲，它的父接口定义的都是扩展内容</p>
<p><strong>接口成员的特点：</strong><br>接口中没有成员变量，只有共有的静态的常量<br>    接口中所有的变量都有一组默认的修饰符 public static final 常量名=常量值，这组修饰符是<br>    系统给的，如果你没写，系统自动加上，如果你写了，系统就不写了<br><strong>接口成员方法的特点：</strong><br><strong>成员方法：</strong><br>  JDK1.7以前，只有共有的抽象的方法<br>  public abstract 返回值类型  方法名（）；这组修饰符也是系统给的<br>  JDK1.8以后，可以有默认方法和静态方法：<br>  public default 返回值类型  方法名（）{}<br>  static 返回值类型 方法名（）{}<br>  JDK9以后，可以有私有方法<br>  private 返回值类型  方法名(){}</p>
<p><strong>接口中构造方法的特点：</strong><br>构造方法：接口不能实例化，也没有需要初始化的成员，所以接口没有构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">smoking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">// jdk1.7以前的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk1.8</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* // jdk1.9</span></span><br><span class="line"><span class="comment">    private void method3() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println("cc");</span></span><br><span class="line"><span class="comment">    &#125;  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">smoking</span>,<span class="title">A</span>,<span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"抽烟有害健康"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//接口不能实例化，</span></span><br><span class="line">        smoking sm=<span class="keyword">new</span> Teacher();</span><br><span class="line">        sm.smoke();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>用于修饰类的成员：不再属于对象了<br>     <strong>成员变量</strong>：类变量<br>        <strong>特点</strong>：被本类所有对象共享<br>        注意：随意修改静态变量的值是有风险的，为了降低风险，可以同时用final关键字修饰，即<br>        共有静态变量<br>     <strong>成员方法</strong>：类方法<br>           静态方法：静态方法中没有对象this，所以不能访问非静态成员<br>           使用场景：<br>           只需要访问静态成员<br>           不需要访问静态状态，所需参数都由参数列表显示提供<br><strong>调用方式：</strong><br>     类名.成员变量名<br>     类名.成员方法名（参数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String work;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String deparmentName=<span class="string">"研发部"</span>;<span class="comment">//为了防止被修改，用final修饰，又因为被所有对象共享，前面加上一个public</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfIntro</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是"</span>+deparmentName+<span class="string">"的"</span>+name+<span class="string">",我的工作内容是"</span>+work);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Developer de=<span class="keyword">new</span> Developer();</span><br><span class="line">        de.name=<span class="string">"aa"</span>;</span><br><span class="line">        de.work=<span class="string">"写代码"</span>;</span><br><span class="line">        <span class="comment">//de.deparmentName="开发部";//一个对象修改，所有对象都修改</span></span><br><span class="line">        de.selfIntro();</span><br><span class="line"></span><br><span class="line">        Developer d2=<span class="keyword">new</span> Developer();</span><br><span class="line">        d2.name=<span class="string">"bb"</span>;</span><br><span class="line">        d2.work=<span class="string">"写代码"</span>;</span><br><span class="line">        d2.selfIntro();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        <span class="comment">//Developer.deparmentName="部门";</span></span><br><span class="line">        de.selfIntro();</span><br><span class="line">        d2.selfIntro();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p><strong>抽象类的概念</strong>：包含抽象方法的类用abstract修饰<br><strong>抽象方法的概念：</strong>只有方法声明，没有方法体的方法，用abstract修饰<br><strong>抽象方法的由来：</strong><br>       当需要定义一个方法，却不明确方法的具体实现时，<br>       可以将方法定义为abstract，具体实现延迟到子类</p>
<p><strong>抽象类的特点：</strong><br>    修饰符：必须用abstract关键字修饰<br>        修饰符abstract class类名{}<br>        修饰符 abstract 返回类型 方法名 ()<br><strong>抽象类不能被实例化，只能创建子类对象</strong><br><strong>抽象类子类的两个选择：</strong><br>     如果是普通类，必须重写父类所有抽象方法<br>     如果是抽象类，则不用重写抽象方法</p>
<p><strong>抽象类成员的特点：</strong><br>    成员变量：<br>          可以有普通的成员变量<br>          也可以有成员常量（final）<br>    成员方法：<br>        可以有普通方法，也可以有抽象方法<br>        抽象类不一定有抽象方法，有抽象方法的类一定是抽象类（或接口）<br>    构造方法：<br>        向普通类一样有构造方法，且可以重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manger</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bouns;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"经理"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBouns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bouns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBouns</span><span class="params">(<span class="keyword">int</span> bouns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bouns = bouns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manger</span><span class="params">(String name, <span class="keyword">double</span> salary, String id, <span class="keyword">int</span> bouns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, id);</span><br><span class="line">        <span class="keyword">this</span>.bouns = bouns;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    小细节：在实际开发中，子类一般有两个构造方法</span></span><br><span class="line"><span class="comment">    子类的空参构造访问父类的空参构造</span></span><br><span class="line"><span class="comment">    子类的全参构造访问父类的全参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"程序员要敲代码"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(String name, <span class="keyword">double</span> salary, String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEmplo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee em=<span class="keyword">new</span> Coder();</span><br><span class="line">        em.work();</span><br><span class="line">        Employee emm=<span class="keyword">new</span> Manger();</span><br><span class="line">        emm.work();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快速实例化</span></span><br><span class="line">        <span class="comment">/* em.setId("111");</span></span><br><span class="line"><span class="comment">        System.out.println(em.getId()); */</span></span><br><span class="line">        Employee c=<span class="keyword">new</span> Coder(<span class="string">"aa"</span>, <span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">        System.out.println(c.getSalary());</span><br><span class="line">        System.out.println(c.getId());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        Manger m=<span class="keyword">new</span> Manger(<span class="string">"bb"</span>, <span class="number">10</span>, <span class="string">"22"</span>, <span class="number">33</span>);</span><br><span class="line">        System.out.println(m.getName());</span><br><span class="line">        System.out.println(m.getId());</span><br><span class="line">        System.out.println(m.getBouns());</span><br><span class="line">        System.out.println(m.getSalary());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2021/05/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h5 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h5><p>划分是先选取一个元素作为基准元素（这个基准元素通常是随机选择的），以数组[4,5,1,6,7,3,2]为例，将4作为基准元素，通过一次划分，把数组分为两部分，其中一部分小于基本元素4，另一部分大于等于基准元素4，此时4就位于了它排序以后最终在的位置，因为它前面的元素都不大于它，它后面的元素都不小于它。</p>
<p>接下来需要对4前面的部分和4后面的部分，分别执行划分，每一次划分总可以排定一个元素，最终可以得到一个有序的数组。</p>
<p>左右两边分别执行划分的过程是递归进行的，快排也使用了分而治之的思想。与归并排序不同的是，快排重点在【分】的上面，每次划分总可以确定一个元素，因此它没有【治】的过程</p>
<p>划分的过程：大放过，小操作，遇到大于等于的元素就什么都不做，继续遍历，而遇到小的元素，就把它们依次交换到数组的前面去。</p>
<h4 id="循环不变量"><a href="#循环不变量" class="headerlink" title="循环不变量"></a>循环不变量</h4><p>我们定义在子区间 [left,right] 里执行划分的过程，其中pivot=nums[left] ，i在一开始位于left+1的位置。</p>
<p>j的定义如下：j 在循环变量i 右移的过程中保持不变的性质是：在i 向右遍历的过程中，总有[left+1,j] &lt; pivot 并且 [j+1,i] &gt;= pivot 成立，在遇到一个比基准元素小的元素，总想方设法把它放到数组的前面去，因此我们更关注小的元素。</p>
<p>初始化，j 的初始值，为了使得初始的区间 [left+1,j] 和区间[j+1,i] 都为空，设置j==left</p>
<p>在i 向右遍历的时候，因为需要保持j以及j之前的元素都小于基准元素，因此：</p>
<ol>
<li>如果i 指向的元素大于等于基准元素pivot的时候，什么都不用做</li>
<li>如果i 指向的元素小于基准元素pivot的时候，j 先向后移动一位，然后交换j和i的值，然后i 再 向前移动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray3(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       <span class="keyword">int</span> len=nums.length;</span><br><span class="line">       quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="comment">//注意这里包括大于的情况</span></span><br><span class="line">       <span class="keyword">if</span> (left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> partition = partition(nums, left, right);</span><br><span class="line">       quickSort(nums,left,partition-<span class="number">1</span>);</span><br><span class="line">       quickSort(nums,partition+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> pivot=nums[left];</span><br><span class="line">       <span class="comment">//循环不变量lt:less than  严格小于</span></span><br><span class="line">       <span class="comment">//[left+1,lt]&lt;pivot  [lt+1,i]&gt;=pivot</span></span><br><span class="line">       <span class="keyword">int</span> lt=left;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i]&lt;pivot)&#123;</span><br><span class="line">               lt++;</span><br><span class="line">               swap(nums,i,lt);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       swap(nums,left,lt);</span><br><span class="line">       <span class="keyword">return</span> lt;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意：越有序的数组，快排消耗的时间越长，与插入排序正好相反</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：   最坏：O(n<em>n)        最好：*O</em>(<em>N</em>log<em>N</em>)         平均时间复杂度：<em>O</em>(<em>N</em>log<em>N</em>)</p>
<p>空间复杂度：<em>O</em>(<em>log*N</em>)</p>
<p>稳定性：不稳定</p>
<h4 id="针对数组中有很多重复元素的解决方案"><a href="#针对数组中有很多重复元素的解决方案" class="headerlink" title="针对数组中有很多重复元素的解决方案"></a>针对数组中有很多重复元素的解决方案</h4><p><strong>方法一：把与pivot相等的元素平均分配到数组的两侧</strong></p>
<p><img src="/2021/05/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210523102439954.png" alt="image-20210523102439954"></p>
<p>这两种切分不管哪一种，和切分元素相等的元素都券别被划分到了一侧，都会是递归树失衡，理想情况是让与切分元素相等的元素分散到数组的两侧</p>
<h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><p>循环不变量，在循环过程中，总有 <strong>[left+1,le）</strong>&lt;=pivot 并且 <strong>（ge,right]</strong>&gt;=pivot 成立；</p>
<p>le 的初始值的left+1,ge 的初始值是right+1，这样上面两个区间都是空区间。</p>
<ul>
<li>le  严格小于pivot 的元素的时候自增，知道遇到一个元素大于等于pivot 的时候停下；</li>
<li>ge  遇到严格大于pivot 的元素的时候自减，直到遇到一个元素小于等于pivot 的时候停下</li>
</ul>
<p>此时 le 来到了第一个大于等于pivot 的位置，ge 来到了第一个小于等于pivot的位置，此时把它们交换，交换以后，它们各自再向中间走一步，重复这样的过程直到它们相遇为止。</p>
<p>注意：当le&gt;ge的时候停止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray3(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意这里包括大于的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> partition = partition2(nums, left, right);</span><br><span class="line">        quickSort(nums,left,partition-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,partition+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标：与切分元素相等的元素均匀的分布在切分元素最终所在为止的两侧</span></span><br><span class="line"><span class="comment">     * [left+1,i]全部小于基准元素</span></span><br><span class="line"><span class="comment">     * [j,right]全部大于基准元素</span></span><br><span class="line"><span class="comment">     * 在指针对撞的过程中，和基准元素相同的元素就被挤到了中间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="comment">//        int randomIndex=left+RANDOM.nextInt(right-left+1);</span></span><br><span class="line"><span class="comment">//        swap(nums,randomIndex,left);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// all in [left + 1, le) &lt;= pivot</span></span><br><span class="line">        <span class="comment">// all in (ge, right] &gt;= pivot</span></span><br><span class="line">        <span class="comment">// le &gt; ge 的时候终止</span></span><br><span class="line">        <span class="keyword">int</span> pivot=nums[left];</span><br><span class="line">        <span class="keyword">int</span> le=left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ge=right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意：这里一定是 nums[le] &lt; pivot，等于 pivot 的元素是被交换过来得到的</span></span><br><span class="line">            <span class="keyword">while</span> (le&lt;=ge &amp;&amp; nums[le]&lt;pivot)le++;</span><br><span class="line">            <span class="comment">// 此时 le 来到第 1 个大于等于 pivot 的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (le&lt;=ge &amp; nums[ge]&gt;pivot)ge--;</span><br><span class="line">            <span class="comment">// 此时 ge 来到第 1 个小于等于 pivot 的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (le&gt;ge)<span class="keyword">break</span>;</span><br><span class="line">            swap(nums,le,ge);</span><br><span class="line">            le++;</span><br><span class="line">            ge--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,le,ge);</span><br><span class="line">        <span class="keyword">return</span> ge;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：把与pivot相等的元素分配到数组的中间</strong></p>
<p><img src="/2021/05/22/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20210523110046213.png" alt="image-20210523110046213"></p>
<p>在循环过程中，总有 [left+1,lt]&lt;pivot, [lt+1,i）=pivot, [gt,right]&gt;=pivot 成立</p>
<p>初始化：i=left+1   lt=left   gt=right+1</p>
<p>遍历到一个元素的时候：</p>
<ul>
<li>如果等于pivot，什么都不做，i 向右移动一格即可</li>
<li>如果严格小于pivot，先把 lt 向右一格，然后交换 lt 与i ，然后i 再向右移动一格</li>
<li>如果严格大于pivot，先把gt 向左移动一格，然后交换gt 与i，此时i 无需移动，因为交换过来的元素还没有看到，可以在下一轮循环中再根据它的带下执行相应的操作。</li>
</ul>
<p>循环终止的时候：</p>
<p>i = gt。因为 [lt + 1, i) 不包括 i。因此，这三个区间正好铺满了整个除了基准元素的那个区间，最后，我们交换一下 left 和 lt 的位置就好了。<br>接下来，我们对区间 [left, lt - 1] （注意这里是 lt - 1）和区间 [gt, right] 分别递归执行下去即可。</p>
<p>三向切分的快速排序能加速排序的原因是：如果执行 partition 的子区间当中，有很多元素都和基准元素相等，那么这些元素都能够在这一轮 partition 中被排定。由于和 pivot 相等的元素都被挤到了中间，它们前面的元素都比 pivot 小，它们后面的元素都比 pivot 大，因此它们就位于排序以后最终应该在的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// all in [left + 1, lt] &lt; pivot</span></span><br><span class="line">        <span class="comment">// all in [lt + 1, i) = pivot</span></span><br><span class="line">        <span class="comment">// all in [gt, right] &gt; pivot</span></span><br><span class="line">        <span class="keyword">int</span> pivot=nums[left];</span><br><span class="line">        <span class="keyword">int</span> lt=left;</span><br><span class="line">        <span class="keyword">int</span> gt=right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;gt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;pivot)&#123;</span><br><span class="line">                lt++;</span><br><span class="line">                swap(nums,i,lt);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]==pivot)i++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                swap(nums,i,gt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,left,lt);</span><br><span class="line">        quickSort3(nums,left,lt);</span><br><span class="line">        quickSort3(nums,gt,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序 快排</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/05/22/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>归并，就是将两个或两个以上的有序序列合并成一个新的有序序列的过程。</p>
<p>说明：这里的序列指的是线性结构的序列，可以是数组，也可以是链表</p>
<p>​          两个数组分别有序是归并得以有效进行的前提</p>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个有序数组：先把值赋值到临时数组，在合并回去</span></span><br><span class="line"><span class="comment">     * 子区间长度：right-left+1</span></span><br><span class="line"><span class="comment">     * 分别用i和j表示当前子区间第一部分的第一个元素的下标和第二部分的第一个元素的下标</span></span><br><span class="line"><span class="comment">     * 用下标k表示马上要赋值回去的那个下标的位置，每次从temp数组中比较，赋值会nums数组，每次比较的时候，都看i和j指向的元素哪个更小</span></span><br><span class="line"><span class="comment">     * 因此，首先是temp[i]&lt;=temp[j]，第一部分先被选出</span></span><br><span class="line"><span class="comment">     * 对于数组下标越界：i和j各自扫描完了的情况</span></span><br><span class="line"><span class="comment">     * 如果i来到了第二部分的第一个元素的位置，此时我们就一直把j指向的元素从前到后依次赋值</span></span><br><span class="line"><span class="comment">     * 如果j来到了第二部分的最后一个元素的后面，此时我们就一直把i指向的元素从前到后依次赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid [left,mid]有序，[mid+1,right]有序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeOfTwoSortedArray</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=right-left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp[i]=nums[left+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i和j分别指向前有序数组和后有序数组的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=mid-left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;len;k++)&#123;</span><br><span class="line">            <span class="comment">//i和j的越界情况</span></span><br><span class="line">            <span class="keyword">if</span> (i==mid-left+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[left+k]=temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j==right-left+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[left+k]=temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp[i]&lt;=temp[j])&#123;<span class="comment">//一定是小于等于，保持稳定性</span></span><br><span class="line">                nums[left+k]=temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[left+k]=temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组nums的子区间[left...right]进行归并排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums,left,mid);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        mergeOfTwoSortedArray(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：<em>O</em>(<em>N</em>log<em>N</em>)</p>
<p>空间复杂度：<em>O</em>(<em>N</em>)</p>
<h4 id="归并排序的优化"><a href="#归并排序的优化" class="headerlink" title="归并排序的优化"></a>归并排序的优化</h4><h5 id="优化一-：在小区间里使用插入排序"><a href="#优化一-：在小区间里使用插入排序" class="headerlink" title="优化一 ：在小区间里使用插入排序"></a>优化一 ：在小区间里使用插入排序</h5><p>可以使用插入排序的原因：</p>
<p>​     首先，操作的指令数更少；</p>
<p>​     其次，插入排序也是稳定的排序算法，修改成插入排序并不影响归并排序的稳定性</p>
<p>当然这个子区间不能很大，子区间在多长的时候呀可以使用插入排序，目前java语言的库函数将它定义为47</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组给定的部分使用插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;left &amp;&amp; arr[j-<span class="number">1</span>]&gt;temp)&#123;</span><br><span class="line">                arr[j]=arr[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="优化二：子区间本身有序则无需归并"><a href="#优化二：子区间本身有序则无需归并" class="headerlink" title="优化二：子区间本身有序则无需归并"></a>优化二：子区间本身有序则无需归并</h5><p>如果这个子区间本身是有序的，我们没有必要执行归并的过程</p>
<p>在代码上只需要判断第一部分的最后一个元素是不是大于第二部分的第一个元素</p>
<p><code>if arr[mid]&lt;=arr[mid+1]return;</code></p>
<h5 id="优化三：在整个归并的过程中，使用同一个辅助数组"><a href="#优化三：在整个归并的过程中，使用同一个辅助数组" class="headerlink" title="优化三：在整个归并的过程中，使用同一个辅助数组"></a>优化三：在整个归并的过程中，使用同一个辅助数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSERTION_SORT_THRESHOLD=<span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 对数组给定的部分使用插入排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">           <span class="keyword">int</span> j=i;</span><br><span class="line">           <span class="keyword">while</span> (j&gt;left &amp;&amp; arr[j-<span class="number">1</span>]&gt;temp)&#123;</span><br><span class="line">               arr[j]=arr[j-<span class="number">1</span>];</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           arr[j]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeOfTwoSortedArray</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i&lt;=right;i++)temp[i]=arr[i];</span><br><span class="line">       <span class="keyword">int</span> i=left;</span><br><span class="line">       <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> k=left;k&lt;=right;k++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (i==mid+<span class="number">1</span>)&#123;</span><br><span class="line">               arr[k]=temp[j];</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j==right+<span class="number">1</span>)&#123;</span><br><span class="line">               arr[k]=temp[i];</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp[i]&lt;=temp[j])&#123;</span><br><span class="line">               arr[k]=temp[i];</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               arr[k]=temp[j];</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">       <span class="comment">//优化1  小区间使用插入排序</span></span><br><span class="line">       <span class="keyword">if</span> (right-left&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">           insertionSort(arr,left,right);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">       mergeSort(arr,left,mid,temp);</span><br><span class="line">       mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">       <span class="comment">//优化2 数组已经有序的情况下，不会合并</span></span><br><span class="line">       <span class="keyword">if</span> (arr[mid]&lt;=arr[mid+<span class="number">1</span>])<span class="keyword">return</span>;</span><br><span class="line">       mergeOfTwoSortedArray(arr,left,mid,right,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray2(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">       <span class="keyword">int</span> len=arr.length;</span><br><span class="line">       <span class="comment">//优化3 全局使用一份临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,len-<span class="number">1</span>,temp);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序 归并</tag>
      </tags>
  </entry>
  <entry>
    <title>成员变量和局部变量</title>
    <url>/2020/07/13/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Descripttion: </span></span><br><span class="line"><span class="comment"> * @Author: Ashley</span></span><br><span class="line"><span class="comment"> * @Date: 2020-07-11 17:20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量，类中方法外</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    private一般修饰成员变量</span></span><br><span class="line"><span class="comment">    public一般修饰成员方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//提供公共的访问方法，分别设置值，获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 成员变量和局部变量的区别： 位置： 初始化值：成员变量有初始值，局部变量没有初始值 作用范围：成员变量再类中，局部变量在方法中</span></span><br><span class="line"><span class="comment">     * 内存中的位置：成员变量再堆中，局部变量再栈中 生命周期：成员变量随着对象的创建而存在，随着对象的消失而消失</span></span><br><span class="line"><span class="comment">     * 局部变量随着方法的调用而存在，随着方法调用结束而消失 注意：如果成员变量和局部变量重名就使用就近原则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量：方法内部，或者参数列表</span></span><br><span class="line">        String name = <span class="string">"小黑"</span>;<span class="comment">// 使用变量的规则遵循就近原则，如果局部位置有，就使用，没有就去本类的成员位置找，没有，就去父类找</span></span><br><span class="line">        System.out.print(name + <span class="string">"正在学习\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">age</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + age + <span class="string">"了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>成员变量和局部变量的区别： </p>
<p><strong>位置</strong>： 成员变量在类中方法外，局部变量，方法内</p>
<p><strong>初始化值</strong>：成员变量有初始值，局部变量没有初始值</p>
<p> <strong>作用范围</strong>：成员变量再类中，局部变量在方法中<br>       <strong>内存中的位置</strong>：成员变量再堆中，局部变量再栈中 </p>
<p><strong>生命周期</strong>：成员变量随着对象的创建而存在，随着对象的消失而消失<br>     <strong>局部变量随着方法的调用而存在，随着方法调用结束而消失 注意：如果成员变量和局部变量重名就使用就近原则</strong></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>成员变量  局部变量</tag>
      </tags>
  </entry>
  <entry>
    <title>构造方法</title>
    <url>/2020/07/13/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>构造方法：帮助创建对象的方法，也就是初始化对象</p>
<p>格式：修饰符  构造方法名（）{}</p>
<p>要求：方法名必须与类名相同；  没有返回值；没有返回值类型</p>
<p>注意：若未提供任何构造方法，系统会提供默认无参构造</p>
<p>若已提供构造方法，系统不再提供无参构造</p>
<p>构造方法可以重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>构造方法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表去重</title>
    <url>/2021/03/25/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<ol>
<li><p>82.删除排序链表中的重复元素</p>
<p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>返回同样按升序排列的结果链表。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode newHead=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            newHead.next=head;</span><br><span class="line">            ListNode pre=newHead;</span><br><span class="line">            ListNode cur=head;</span><br><span class="line">            ListNode next=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                next=cur.next;</span><br><span class="line">                <span class="keyword">if</span>(cur.val==next.val)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(next!=<span class="keyword">null</span> &amp;&amp; cur.val==next.val)&#123;</span><br><span class="line">                        next=next.next;</span><br><span class="line">                        cur=cur.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre.next=next;</span><br><span class="line">                    cur=cur.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                    cur=cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入循环时，确保了 head 不会与上一节点相同</span></span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.val != head.next.val) &#123;</span><br><span class="line">                tail.next = head;</span><br><span class="line">                tail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 head 与下一节点相同，跳过相同节点</span></span><br><span class="line">            <span class="keyword">while</span> (head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) head = head.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>83  删除排序链表中的重复节点—保留重复节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.val!=slow.val)&#123;</span><br><span class="line">                slow.next=fast;</span><br><span class="line">                slow=slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2021/05/22/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>将一个元素插入到有序数组中，使之成为更长的有序数组</p>
<p>具体来说，我们需要从第二个数开始，一次把这个数插入到它之前已经排好序的部分，这样每一次都能得到比上一次更长的有序数组，直到数组整体有序</p>
<h4 id="将一个元素插入一个有序数组的两种方式"><a href="#将一个元素插入一个有序数组的两种方式" class="headerlink" title="将一个元素插入一个有序数组的两种方式"></a>将一个元素插入一个有序数组的两种方式</h4><ol>
<li>逐个交换到前面合适的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="comment">//将nums[i]插入到区间[0,i]使之成为有序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j-<span class="number">1</span>]&gt;nums[j])swap(nums,j-<span class="number">1</span>,j);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*n)</p>
<p>空间复杂度：O(1)</p>
<ol start="2">
<li>先暂存当前变量，然后将前面若干个元素逐个向后赋值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insertSort2(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="comment">//            先暂存这个变量，然后之前数值严格小于temp的所有元素后移</span></span><br><span class="line">            <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; nums[j-<span class="number">1</span>]&gt;temp)&#123;</span><br><span class="line">                nums[j]=nums[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>与选择排序不同的是，插入排序比较的方式是从后向前将依次看到的元素与待插入的元素进行比较，这一步操作不同比较完它前面所有的元素，即：插入排序的内层循环可以提前终止，这一点是插入排序非常重要的性质</p>
<p>如果待排序的数组是接近有序的数组和元素个数较少的数组，插入排序就可以很快的完成排序任务，选择排序不具备这样的特点。一个非常极端的例子是：对一个已经排好序的数组，使用插入排序，每一轮插入排序就只要看一个前面的那个元素，发现不能再往前移动了，马上进入下一层循环</p>
<p>结论：插入排序最好的时间复杂度是：O（n）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序 插入</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习四剑客</title>
    <url>/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p><strong>numpy就是用来进行矩阵计算的</strong></p>
<p>Numpy中文网：<a href="https://www.numpy.org.cn/" target="_blank" rel="noopener">https://www.numpy.org.cn/</a></p>
<ol>
<li><p>创建数组</p>
<p><code>np.array()</code></p>
</li>
<li><p>除了np.array之外，还有一些函数也可以新建数组：</p>
<ol>
<li><p>zeros和ones分别可以创建指定长度或者形状的全0或全1数组</p>
</li>
<li><p>Empty可以创建一个没有任何具体值的数组</p>
</li>
</ol>
</li>
<li><p>查看数组属性</p>
<ol>
<li>b.size——数组元素的个数</li>
<li>B.shape—–数组形状</li>
<li>B.ndim——数组维度</li>
<li>B.dtype—-数组元素类型</li>
</ol>
</li>
<li><p>矩阵乘法</p>
<p>Np.dot()</p>
</li>
</ol>
<h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p><strong>pandas基于numpy，丰富并简化了numpy的操作</strong></p>
<h2 id="Series-一维数据"><a href="#Series-一维数据" class="headerlink" title="Series(一维数据)"></a>Series(一维数据)</h2><p><strong>pandas中文网：<a href="https://www.pypandas.cn/" target="_blank" rel="noopener">https://www.pypandas.cn/</a></strong></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503234256071.png" alt="image-20200503234256071"><strong>Series的字符串表现形式为：</strong></p>
<p>1.索引在左边，值在右边</p>
<p>2.如果没有为数据指定索引，则自动创建一个0到N-1（N为数据的长度）的整数型索引</p>
<p>可以通过Series的values和index属性获取其数组表示形式和索引对象</p>
<p>4.与普通numpy数组相比，可以通过索引的方式选取Series中的单个或一组值</p>
<h2 id="DataFrame-多特征数据，既有行索引，又有列索引"><a href="#DataFrame-多特征数据，既有行索引，又有列索引" class="headerlink" title="DataFrame(多特征数据，既有行索引，又有列索引)"></a>DataFrame(多特征数据，既有行索引，又有列索引)</h2><p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）</p>
<p>DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）</p>
<p>跟其他类似的数据结构相比（如R语言的data.frame），DataFrame中面向行和面向列的操作基本上是平衡的  </p>
<p>DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）</p>
<p>构成DataFrame的方法很多，最常用的一种是直接传入一个由等长列表或numpy数组组成的字典</p>
<p>DataFrame结果会自动加上索引（跟Series一样），且全部会被有序排列</p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503235032148.png" alt="image-20200503235032148"></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503235921318.png" alt="image-20200503235921318"></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200504000009032.png" alt="image-20200504000009032"></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200504000141684.png" alt="image-20200504000141684"></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200504000230798.png" alt="image-20200504000230798"></p>
<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p><strong>绘图和可视化</strong></p>
<p>Matplotlib中文网：<a href="https://www.matplotlib.org.cn" target="_blank" rel="noopener">https://www.matplotlib.org.cn</a></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503235215214.png" alt="image-20200503235215214"></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503235250949.png" alt="image-20200503235250949"></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503235329162.png" alt="image-20200503235329162"></p>
<h1 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h1><p><strong>对图像进行处理</strong></p>
<p><img src="/2020/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E5%89%91%E5%AE%A2/image-20200503235410828.png" alt="image-20200503235410828"></p>
]]></content>
      <categories>
        <category>deeplearning</category>
      </categories>
      <tags>
        <tag>python库</tag>
      </tags>
  </entry>
  <entry>
    <title>空间复杂度</title>
    <url>/2021/04/09/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>什么是空间复杂度呢？</p>
<p>是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)。</p>
<p>空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p>
<p>关注空间复杂度有两个常见的相关问题</p>
<ol>
<li>空间复杂度是考虑程序（可执行文件）的大小吗？</li>
</ol>
<p><strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong></p>
<ol start="2">
<li><p>空间复杂度是准确算出程序运行时所占用的内存吗？</p>
<p>不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很有多因素会影响程序真正内存使用大小，例如<strong>编译器的内存对齐，编程语言容器的底层实现</strong>等等这些都会影响到程序内存的开销。</p>
<p>所以空间复杂度是预先大体评估程序内存使用的大小。</p>
<p>说到空间复杂度，大家在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。</p>
<p>为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。</p>
<p>同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。</p>
</li>
</ol>
<p>那么什么时候空间复杂度是O(1)呢？</p>
<p><img src="/2021/04/09/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409155057641.png" alt="image-20210409155057641"></p>
<p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大 O(1)。</p>
<p>什么时候的空间复杂度是O(n)呢？</p>
<p>当小号空间和输入参数n保持线性增长，这样的空间复杂度为O(n)</p>
<p><img src="/2021/04/09/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210409155209893.png" alt="image-20210409155209893"></p>
<p>我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p>
<p>什么时候的空间复杂度为 <strong>O(logn)呢？</strong></p>
<p>空间复杂度是logn的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/zLeRB-GPc3q4DG-a5cQLVw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zLeRB-GPc3q4DG-a5cQLVw</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2020/07/13/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>子类拥有了父类的非私有成员（成员变量，成员方法）</p>
<p>多个类中存在相同的属性和行为时，可以将这些内容提取出来放到一个新类中</p>
<p>让这些类和新类产生父子关系，实现代码的复用</p>
<p><strong>继承关系中成员变量使用结论：</strong></p>
<p>查找变量的原则：<strong>就近原则</strong></p>
<p>查找变量的顺序：局部变量–》成员变量–》父类–》更高的父类–》。。。object</p>
<p>访问父类变量的方式：super.父类变量名</p>
<p>super：当前对象父类的引用（父类内存空间的标识）</p>
<p>对象初始化顺序：先初始化父类内容，再初始化子类内容</p>
<p><strong>java中继承的特点</strong><br><strong>单继承</strong>：java只支持类的单继承，但是支持多层继承<br>       java支持接口的多继承，语法为：<br>       接口A extends 接口B，接口C，。。。<br><strong>私有成员不能继承</strong>：<br>            只能继承父类的非私有成员（成员变量，成员方法）<br><strong>构造方法不能被继承</strong>：<br>            构造方法用于初始化本类对象<br>            创造子类对象时，需要调用父类构造初始化该对象的父类内容，若父类<br>            可以被继承，该操作会造成调用的混乱<br><strong>继承体现了 is a 的关系：</strong><br>子类符合 is a (是一个)父类的情况，才使用继承，其他情况不建议使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 创建子类对象时，优先调用父类的构造方法</span></span><br><span class="line"><span class="comment">           子类构造方法的第一行，隐含语句super()，用于调用父类的类默认无参构造</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">           如果父类不存在默认无参构造，须手动调用父类其他构造*/</span></span><br><span class="line">        <span class="comment">//super();//调用父类默认无参构造,用于初始化父类成员，必须在第一行</span></span><br><span class="line">        <span class="comment">//super("Ashley");</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"worker"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line"></span><br><span class="line">    int num&#x3D;20;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;&#x2F;&#x2F;注意输出的顺序</span><br><span class="line">        int num&#x3D;10;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(this.num);</span><br><span class="line">        System.out.println(super.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>背包九讲</title>
    <url>/2020/05/06/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</url>
    <content><![CDATA[<p><strong>背包九讲</strong></p>
<p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">https://www.cnblogs.com/jbelial/articles/2116074.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>状态压缩</title>
    <url>/2020/05/29/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>最近做Leetcode上第1371（<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/）的题目，用到的知识点是状态压缩+前缀和，对于状态压缩" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/）的题目，用到的知识点是状态压缩+前缀和，对于状态压缩</a></p>
<p>却迟迟理解不了，于是上网查了很多的资料，<strong>一句话总结就是用一串二进制数来表示当前情况的状态</strong></p>
<p>参考如下：</p>
<p><a href="https://blog.csdn.net/u011077606/article/details/43487421?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/u011077606/article/details/43487421?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<p><a href="https://blog.csdn.net/fjy19950504/article/details/105929173/" target="_blank" rel="noopener">https://blog.csdn.net/fjy19950504/article/details/105929173/</a></p>
<p><a href="https://blog.csdn.net/lu597203933/article/details/44137277" target="_blank" rel="noopener">https://blog.csdn.net/lu597203933/article/details/44137277</a></p>
<p>状态压缩用的到知识点主要是Java中的位运算，也有一方面是自己对位运算的理解不透彻，先把位运算的知识点总结如下：</p>
<ol>
<li>&amp;：x&amp;y，将两个十进制数在二进制下进行<strong>与</strong>运算，然后返回其十进制下的值（规则是两个同时为1，结果为1，否则为0），例如3（11）&amp;2（10）=2（10）</li>
<li>|：x|y，将两个十进制数在二进制下进行<strong>或</strong>运算，然后返回其十进制下的值（规则是一个为1，其值为1），例如：3（11）|2（10）=3（11）</li>
<li>^：x ^ y：将两个十进制的值在二进制下进行<strong>异或</strong>运算，然后返回其十进制下的值（规则是相同为0，不同为1），例如：3（11）^ 2（10）=1（01）</li>
<li>&lt;&lt;：左移操作，x&lt;&lt;2，将x在二进制下的每一位向左移动两位，最右边用0填充，相当于让x乘以4</li>
<li>&lt;&lt;：右移操作，x&gt;&gt;1，相当于x/2，去掉x最右一位</li>
<li><u><em>判断一个数字x二进制下第i位是不是等于1。</em></u><br><u><em>方法：if(((1&lt;&lt;(i−1))&amp;x)&gt;0)</em></u><br><u><em>将1左移i-1位，相当于制造了一个只有第i位上是1，其他位上都是0的二进制数。然后与x做与运算，如果结果&gt;0，说明x第i位上是1，反之则是0。</em></u></li>
<li><u><em>将一个数字x二进制下第i位更改成1。</em></u><br><u><em>方法：x=x|(1&lt;&lt;(i−1))</em></u></li>
<li><u><em>把一个数字二进制下最靠右的第一个1去掉。</em></u><br><u><em>方法：x=x&amp;(x−1)</em></u></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>重载和重写</title>
    <url>/2020/07/13/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>方法重载：在同一类中的多个方法，它们的方法名相同，参数列表不同，</p>
<p>   这样的情况称为方法重载，<strong>方法重载与返回值类型和修饰符无关</strong></p>
<p>   参数列表不同：参数的个数不同；对应位置的参数类型不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">compare</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean  <span class="title">compare</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>子类中出现和父类方法定义相同的方法的现象</p>
<p>解释：方法重写也叫方法覆写，覆盖，<strong>方法名，参数列表，返回值类型都相同</strong></p>
<p><strong>注意：</strong></p>
<p>父类私有方法无法重写</p>
<p>子类方法访问权限不能小于父类方法</p>
<p>子类不能比父类抛出更大的异常</p>
<p>使用场景：扩展父类功能</p>
<p>父类功能过时，重新实现父类的功能 </p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>重载 重写</tag>
      </tags>
  </entry>
  <entry>
    <title>集合和泛型</title>
    <url>/2020/07/14/%E9%9B%86%E5%90%88%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="集合和数组的区别："><a href="#集合和数组的区别：" class="headerlink" title="集合和数组的区别："></a>集合和数组的区别：</h1><p>元素类型：<br>集合：引用类型（存储基本类型时自动装箱）<br>数组：基本类型，引用类型<br>元素个数：<br>集合：不固定，可任意扩容<br>数组：固定，不能改变容量<br>集合的好处：<br>不受容器大小限制，可以随意添加删除元素<br>提供了大量操作元素的方法（判断获取等）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">单列集合（Collection）之List集合：</span></span><br><span class="line"><span class="comment">特点：有序（元素的存取顺序一致），可重复</span></span><br><span class="line"><span class="comment">注意：list是接口，所以通过创建其子类对象来完成该接口的实例化</span></span><br><span class="line"><span class="comment">List list=new ArrayList();</span></span><br><span class="line"><span class="comment">使用集合的步骤：</span></span><br><span class="line"><span class="comment">1创建集合对象</span></span><br><span class="line"><span class="comment">2创建集合元素</span></span><br><span class="line"><span class="comment">3将元素添加到集合对象中</span></span><br><span class="line"><span class="comment">4遍历集合</span></span><br><span class="line"><span class="comment">list接口中的成员方法：</span></span><br><span class="line"><span class="comment">public boolean add(E s)&#123;&#125;   将数据添加到集合的末尾</span></span><br><span class="line"><span class="comment">public E get(int index)&#123;&#125;  根据索引获取对应的元素</span></span><br><span class="line"><span class="comment">public int size()&#123;&#125;获取集合的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Str stu1=<span class="keyword">new</span> Str(<span class="string">"aa"</span>, <span class="number">26</span>);</span><br><span class="line">        Str stu2=<span class="keyword">new</span> Str(<span class="string">"aa"</span>, <span class="number">26</span>);</span><br><span class="line">        Str stu3=<span class="keyword">new</span> Str(<span class="string">"bb"</span>, <span class="number">33</span>);</span><br><span class="line">        Str stu4=<span class="keyword">new</span> Str(<span class="string">"aa"</span>, <span class="number">36</span>);</span><br><span class="line">        list.add(stu1);</span><br><span class="line">        list.add(stu2);</span><br><span class="line">        list.add(stu3);</span><br><span class="line">        list.add(stu4);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Object obj=list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            Object obj2=list.get(i);</span><br><span class="line">            System.out.println(<span class="string">"索引为"</span>+i+<span class="string">"是"</span>+obj2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj3:list)&#123;</span><br><span class="line">            System.out.println(obj3);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        List list2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(<span class="number">10</span>);</span><br><span class="line">        list2.add(<span class="number">20</span>);</span><br><span class="line">        list2.add(<span class="number">30</span>);</span><br><span class="line">        list2.add(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obj4 : list2) &#123;</span><br><span class="line">            <span class="comment">//ojj4是集合中的元素，其本身应该是Integer类型的元素，转换，可以使用Integer类型找那个的方法</span></span><br><span class="line">            Integer ii=(Integer)obj4;</span><br><span class="line">            System.out.println(obj4);</span><br><span class="line">            System.out.println(ii);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        Integer in=Collections.max(list);</span><br><span class="line">        System.out.println(in);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        <span class="comment">//随机置换，相当于洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">// 无序，唯一</span></span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="string">"aa"</span>, <span class="number">1</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">"aa"</span>, <span class="number">1</span>);</span><br><span class="line">        Student stu3 = <span class="keyword">new</span> Student(<span class="string">"bb"</span>, <span class="number">1</span>);</span><br><span class="line">        Student stu4 = <span class="keyword">new</span> Student(<span class="string">"cc"</span>, <span class="number">1</span>);</span><br><span class="line">        Student stu5 = <span class="keyword">new</span> Student(<span class="string">"dd"</span>, <span class="number">1</span>);</span><br><span class="line">        set.add(stu1);</span><br><span class="line">        set.add(stu2);</span><br><span class="line">        set.add(stu3);</span><br><span class="line">        set.add(stu4);</span><br><span class="line">        set.add(stu5);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 没有去重，因为set集合保证元素的唯一性依赖equals()和hashcode()两个方法</span></span><br><span class="line"><span class="comment">         * 没有在student中重写这两个方法，默认调用的是object类找那个的这两个方法 而object类中的equals（）默认比较的是地址值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        Iterator&lt;Student&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Student s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student ss : set) &#123;</span><br><span class="line">            System.out.print(ss);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h1><p>对过程的重复，称为迭代<br>迭代器是遍历Collection集合的通用方式，可以在对集合遍历的同事进行添加删除等操作<br>迭代器的常用方法：<br>next（）：返回迭代的下一个元素<br>hasNext（）：如果仍有元素可以迭代，返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator it = list.iterator();<span class="comment">// 迭代器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * while(it.hasNext())&#123; String s=(String)it.next(); System.out.println(s); &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String s = (String) it.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"b"</span>.equals(s)) &#123;<span class="comment">// 这样写可以规避空指针异常</span></span><br><span class="line">                <span class="comment">// list.add("java");//这样写错误，会报并发修改异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        普通迭代器在遍历集合的同时不能添加或删除元素，否则会报并发修改异常</span></span><br><span class="line"><span class="comment">        列表迭代器在遍历集合的同事可以修改集合中的元素（添加修改等），必须使用列表迭代器中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ListIterator lit = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">            String ss = (String) lit.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"b"</span>.equals(ss)) &#123;</span><br><span class="line">                lit.add(<span class="string">"java"</span>);<span class="comment">//必须调用列表迭代器中的方法</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIter2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator lit=list.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())&#123;</span><br><span class="line">            String s=(String)lit.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"b"</span>.equals(s))&#123;</span><br><span class="line">                lit.add(<span class="string">"java"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h1><p>泛指任意类型，又叫参数化类型<br>对具体类型的使用起到辅助作用，类似于方法的参数<br>集合类泛型的解释：<br>表示该集合中存放指定类型的元素<br>List<String> list=new ArrayList&lt;&gt;();<br><strong>泛型的安全：</strong><br>类型安全<br>避免了类型转换<br>总结：泛型一般只和集合类相使用<br>泛型是jdk5的新特性，但是jdk7开始后面的泛型可以不用写具体的数据类型了</String></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>集合  泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2021/05/22/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h4><p>从小到大一次选出第一个元素，第二个元素，通过交换达到选择和排序的目的</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * 每一轮都选取为排定部分的最小元素，然后将它交换到未排定的部分的第一个位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">//最后一轮只有一个元素，一定是最大元素，因此是len-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex=i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j]&lt;nums[minIndex])&#123;</span><br><span class="line">                    minIndex=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,minIndex,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度:O(n*n)</p>
<p>空间复杂度：O(1)</p>
<h4 id="选择排序的特点"><a href="#选择排序的特点" class="headerlink" title="选择排序的特点"></a>选择排序的特点</h4><p><strong>交换的次数最少</strong></p>
<p>如果一个排序任务交换的成本很高，可以考虑使用选择排序</p>
<p><strong>运行时间与输入无关</strong></p>
<p>每一趟扫描，除了扫描的元素比上一轮上了一个意外与，选择排序没有记住更多的信息。一个极端的例子是：已经是排好序的数组，选择排序还需要一次又一次的扫描</p>
<p><strong>这两点是选择排序区别其他排序算的特点</strong></p>
<h4 id="选择排序体现的算法思想"><a href="#选择排序体现的算法思想" class="headerlink" title="选择排序体现的算法思想"></a>选择排序体现的算法思想</h4><p>贪心算法</p>
<p>减而治之</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序 选择</tag>
      </tags>
  </entry>
  <entry>
    <title>青春有你2五人识别</title>
    <url>/2020/05/04/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A02%E4%BA%94%E4%BA%BA%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p><strong>工具准备</strong></p>
<p>Paddlehub:<a href="https://www.paddlepaddle.org.cn/hub" target="_blank" rel="noopener">https://www.paddlepaddle.org.cn/hub</a></p>
<p>github地址：<a href="https://github.com/PaddlePaddle/PaddleHub" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleHub</a></p>
<p><strong>paddlehub学习</strong></p>
<p>PaddleHub的课程地址：<a href="https://aistudio.baidu.com/aistudio/course/introduce/1070" target="_blank" rel="noopener">https://aistudio.baidu.com/aistudio/course/introduce/1070</a></p>
<p>PaddleHub的教程地址：<a href="https://aistudio.baidu.com/aistudio/personalcenter/thirdview/79927" target="_blank" rel="noopener">https://aistudio.baidu.com/aistudio/personalcenter/thirdview/79927</a></p>
<p>PaddleHub的模型地址：<a href="https://github.com/PaddlePaddle/PaddleHub/tree/release/v1.6/demo" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleHub/tree/release/v1.6/demo</a></p>
<p><strong>安装</strong></p>
<p>pip install paddlehub==1.6.0 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p><strong>数据集</strong></p>
<p>我是自己爬虫获得的，不知道怎么上传，就不上传了</p>
<h1 id="1-加载数据文件，也可以直接上传，我只是为了记住这个命令"><a href="#1-加载数据文件，也可以直接上传，我只是为了记住这个命令" class="headerlink" title="1. 加载数据文件，也可以直接上传，我只是为了记住这个命令"></a>1. 加载数据文件，也可以直接上传，我只是为了记住这个命令</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!unzip -o file.zip -d ./dataset/</span><br><span class="line"><span class="keyword">import</span> paddlehub ad hub</span><br></pre></td></tr></table></figure>

<h1 id="2-加载预训练模型"><a href="#2-加载预训练模型" class="headerlink" title="2. 加载预训练模型"></a>2. 加载预训练模型</h1><p>在paddlehub中选择合适的预训练模型来finetune，此处选择的是经典的resnet-50作为预训练模型，也可以选择其他的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module = hub.Module(name=<span class="string">"resnet_v2_50_imagenet"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="3-数据准备"><a href="#3-数据准备" class="headerlink" title="3. 数据准备"></a>3. 数据准备</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlehub.dataset.base_cv_dataset <span class="keyword">import</span> BaseCVDataset</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoDataset</span><span class="params">(BaseCVDataset)</span>:</span>	</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>	</span><br><span class="line">       <span class="comment"># 数据集存放位置</span></span><br><span class="line">       </span><br><span class="line">       self.dataset_dir = <span class="string">"dataset"</span></span><br><span class="line">       super(DemoDataset, self).__init__(</span><br><span class="line">           base_path=self.dataset_dir,</span><br><span class="line">           train_list_file=<span class="string">"train_list.txt"</span>,<span class="comment">#训练集</span></span><br><span class="line">           validate_list_file=<span class="string">"validate_list.txt"</span>,<span class="comment">#验证集</span></span><br><span class="line">           test_list_file=<span class="string">"test_list.txt"</span>,<span class="comment">#测试集</span></span><br><span class="line">           label_list_file=<span class="string">"label_list.txt"</span>,<span class="comment">#标签列表</span></span><br><span class="line">           )</span><br><span class="line">dataset = DemoDataset()</span><br></pre></td></tr></table></figure>

<h1 id="4-生成数据读取器"><a href="#4-生成数据读取器" class="headerlink" title="4.生成数据读取器"></a>4.生成数据读取器</h1><p>接着生成一个图像分类的reader,reader负责将dataset的数据进行预处理，接着以特定格式组织并输入模型进行训练。当生成一个图像分类的reader时，需要指定输入图片的大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_reader = hub.reader.ImageClassificationReader(</span><br><span class="line">    image_width=module.get_expected_image_width(),</span><br><span class="line">    image_height=module.get_expected_image_height(),</span><br><span class="line">    images_mean=module.get_pretrained_images_mean(),</span><br><span class="line">    images_std=module.get_pretrained_images_std(),</span><br><span class="line">    dataset=dataset)</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<p><img src="/2020/05/04/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A02%E4%BA%94%E4%BA%BA%E8%AF%86%E5%88%AB/image-20200504170951354.png" alt="image-20200504170951354"></p>
<h1 id="5-配置策略"><a href="#5-配置策略" class="headerlink" title="5.配置策略"></a>5.配置策略</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = hub.RunConfig(</span><br><span class="line">    use_cuda=<span class="literal">False</span>,                              <span class="comment">#是否使用GPU训练，默认为False；</span></span><br><span class="line">    num_epoch=<span class="number">3</span>,                                <span class="comment">#Fine-tune的轮数；</span></span><br><span class="line">    checkpoint_dir=<span class="string">"cv_finetune_turtorial_demo"</span>,<span class="comment">#模型checkpoint保存路径, 若用户没有指定，程序会自动生成；</span></span><br><span class="line">    batch_size=<span class="number">3</span>,                              <span class="comment">#训练的批大小，如果使用GPU，请根据实际情况调整batch_size；</span></span><br><span class="line">    eval_interval=<span class="number">10</span>,                           <span class="comment">#模型评估的间隔，默认每100个step评估一次验证集；</span></span><br><span class="line">    strategy=hub.finetune.strategy.DefaultFinetuneStrategy())  <span class="comment">#Fine-tune优化策略；</span></span><br></pre></td></tr></table></figure>

<h1 id="6-组建finetune-task"><a href="#6-组建finetune-task" class="headerlink" title="6.组建finetune task"></a>6.组建finetune task</h1><p>有了合适的训练模型和准备要迁移的数据后，我们开始组建一个task</p>
<p>因为module是在ImageNet数据集上训练的千分类模型，所以需要对模型进行调整</p>
<ol>
<li>获取module的上下文环境，包括输入和输出变量，以及paddle program</li>
<li>从输入变量中找到特征图提取层feature_map</li>
<li>在feature_map后面接入一个全连接层，生成task</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_dict, output_dict, program = module.context(trainable=<span class="literal">False</span>)</span><br><span class="line">img = input_dict[<span class="string">"image"</span>]</span><br><span class="line">feature_map = output_dict[<span class="string">"feature_map"</span>]</span><br><span class="line">feed_list = [img.name]</span><br><span class="line"></span><br><span class="line">task = hub.ImageClassifierTask(</span><br><span class="line">    data_reader=data_reader,</span><br><span class="line">    feed_list=feed_list,</span><br><span class="line">    feature=feature_map,</span><br><span class="line">    num_classes=dataset.num_labels,</span><br><span class="line">    config=config)</span><br></pre></td></tr></table></figure>

<h1 id="7-开始finetune"><a href="#7-开始finetune" class="headerlink" title="7.开始finetune"></a>7.开始finetune</h1><p>Finetune_and_eval接口在finetune的过程中，会周期性的进行模型效果的评估，方便我们了解整个训练过程中的性能变化</p>
<p><code>run_states=task.finetune_and_eval()</code></p>
<p>运行结果</p>
<p><img src="/2020/05/04/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A02%E4%BA%94%E4%BA%BA%E8%AF%86%E5%88%AB/image-20200504172355292.png" alt="image-20200504172355292"></p>
<h1 id="8-预测"><a href="#8-预测" class="headerlink" title="8.预测"></a>8.预测</h1><p>当finetune完成后，我们使用模型来进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"dataset/temp.txt"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    filepath = f.readlines()</span><br><span class="line"></span><br><span class="line">data = [filepath[<span class="number">0</span>].split(<span class="string">" "</span>)[<span class="number">0</span>],filepath[<span class="number">1</span>].split(<span class="string">" "</span>)[<span class="number">0</span>],filepath[<span class="number">2</span>].split(<span class="string">" "</span>)[<span class="number">0</span>],filepath[<span class="number">3</span>].split(<span class="string">" "</span>)[<span class="number">0</span>],filepath[<span class="number">4</span>].split(<span class="string">" "</span>)[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">label_map = dataset.label_dict()</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">run_states = task.predict(data=data)</span><br><span class="line">results = [run_state.run_results <span class="keyword">for</span> run_state <span class="keyword">in</span> run_states]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> batch_result <span class="keyword">in</span> results:</span><br><span class="line">    print(batch_result)</span><br><span class="line">    batch_result = np.argmax(batch_result, axis=<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    print(batch_result)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> batch_result:</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        result = label_map[result]</span><br><span class="line">        print(<span class="string">"input %i is %s, and the predict result is %s"</span> %</span><br><span class="line">              (index, data[index - <span class="number">1</span>], result))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/05/04/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A02%E4%BA%94%E4%BA%BA%E8%AF%86%E5%88%AB/image-20200504172547233.png" alt="image-20200504172547233"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>python 图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title>青春有你信息爬取</title>
    <url>/2020/05/03/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A0%E4%BF%A1%E6%81%AF%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p><strong>写在前面</strong></p>
<p>本篇是在百度飞桨学习的第二天的知识点，觉得很有用，所以记录一下。任务是爬取百度百科中青春有你2所有参赛选手的信息</p>
<p><strong>深度学习的一般过程：</strong></p>
<p><img src="/2020/05/03/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A0%E4%BF%A1%E6%81%AF%E7%88%AC%E5%8F%96/image-20200503171342778.png" alt="image-20200503171342778"></p>
<p><strong>收集数据，尤其是有标签，高质量的数据是一件昂贵的工作</strong></p>
<p><strong>爬虫</strong> 的过程，就是模仿浏览器的行为，往目标站点发送请求，接收服务器的响应数据，提取需要的信息，并进行保存的过程。</p>
<p><strong>上网的全过程</strong></p>
<table>
<thead>
<tr>
<th>普通用户：</th>
<th>爬虫的程序</th>
</tr>
</thead>
<tbody><tr>
<td>打开浏览器—-&gt;往目标站点发送请求—–&gt;接受响应数据—–&gt;渲染到页面上</td>
<td>模拟浏览器 –&gt; 往目标站点发送请求 –&gt; 接收响应数据 –&gt; 提取有用的数据 –&gt; 保存到本地/数据库。</td>
</tr>
</tbody></table>
<p><strong>爬虫的过程</strong></p>
<ol>
<li><p>发送请求（request模块）</p>
</li>
<li><p>获取响应的数据（服务器返回）</p>
</li>
<li><p>解析并提取数据（BeautifulSoup查找或者re正则）</p>
</li>
<li><p>保存数据</p>
<p>BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。网址：<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/</a> BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml。 BeautifulSoup(markup, “html.parser”)或者BeautifulSoup(markup, “lxml”)，推荐使用lxml作为解析器,因为效率更高。</p>
<p><strong>开始前先安装lxml和beautifulSoup</strong></p>
</li>
</ol>
<h1 id="一-爬取青春有你2中所有参赛选手的信息，返回页面数据"><a href="#一-爬取青春有你2中所有参赛选手的信息，返回页面数据" class="headerlink" title="一.爬取青春有你2中所有参赛选手的信息，返回页面数据"></a>一.爬取青春有你2中所有参赛选手的信息，返回页面数据</h1>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">from bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">#获取当天的日期,并进行格式化,用于后面文件命名，格式:20200420</span><br><span class="line">today = datetime.date.today().strftime(<span class="string">'%Y%m%d'</span>)    </span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">crawl_wiki_data</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    """</span></span><br><span class="line"><span class="function">    爬取百度百科中《青春有你2》中参赛选手信息，返回html</span></span><br><span class="line"><span class="function">    """</span></span><br><span class="line"><span class="function">    headers </span>= &#123; </span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">    url=<span class="string">'https://baike.baidu.com/item/青春有你第二季'</span>                         </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url,headers=headers)</span><br><span class="line">        print(response.status_code)</span><br><span class="line"></span><br><span class="line">        #将一段文档传入BeautifulSoup的构造方法,就能得到一个文档的对象, 可以传入一段字符串</span><br><span class="line">        soup = BeautifulSoup(response.text,<span class="string">'lxml'</span>)</span><br><span class="line">        </span><br><span class="line">        #返回的是class为table-view log-set-param的&lt;table&gt;所有标签</span><br><span class="line">        tables = soup.find_all(<span class="string">'table'</span>,&#123;<span class="string">'class'</span>:<span class="string">'table-view log-set-param'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        crawl_table_title = <span class="string">"参赛学员"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> table in  tables:           </span><br><span class="line">            #对当前节点前面的标签和字符串进行查找</span><br><span class="line">            table_titles = table.find_previous(<span class="string">'div'</span>).find_all(<span class="string">'h3'</span>)</span><br><span class="line">            <span class="keyword">for</span> title in table_titles:</span><br><span class="line">                <span class="keyword">if</span>(crawl_table_title in title):</span><br><span class="line">                    <span class="keyword">return</span> table       </span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>

<h1 id="二-对爬取的页面数据进行解析，并保存为json文件"><a href="#二-对爬取的页面数据进行解析，并保存为json文件" class="headerlink" title="二.对爬取的页面数据进行解析，并保存为json文件"></a>二.对爬取的页面数据进行解析，并保存为json文件</h1>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">parse_wiki_data</span><span class="params">(table_html)</span>:</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    从百度百科返回的html中解析得到选手信息，以当前日期作为文件名，存JSON文件,保存到work目录下</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    bs </span>= BeautifulSoup(str(table_html),<span class="string">'lxml'</span>)</span><br><span class="line">    all_trs = bs.find_all(<span class="string">'tr'</span>)</span><br><span class="line"></span><br><span class="line">    error_list = [<span class="string">'\''</span>,<span class="string">'\"'</span>]</span><br><span class="line"></span><br><span class="line">    stars = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> tr in all_trs[<span class="number">1</span>:]:</span><br><span class="line">         all_tds = tr.find_all(<span class="string">'td'</span>)</span><br><span class="line"></span><br><span class="line">         star = &#123;&#125;</span><br><span class="line"></span><br><span class="line">         #姓名</span><br><span class="line">         star[<span class="string">"name"</span>]=all_tds[<span class="number">0</span>].text</span><br><span class="line">         #个人百度百科链接</span><br><span class="line">         star[<span class="string">"link"</span>]= <span class="string">'https://baike.baidu.com'</span> + all_tds[<span class="number">0</span>].find(<span class="string">'a'</span>).get(<span class="string">'href'</span>)</span><br><span class="line">         #籍贯</span><br><span class="line">         star[<span class="string">"zone"</span>]=all_tds[<span class="number">1</span>].text</span><br><span class="line">         #星座</span><br><span class="line">         star[<span class="string">"constellation"</span>]=all_tds[<span class="number">2</span>].text</span><br><span class="line">         #身高</span><br><span class="line">         star[<span class="string">"height"</span>]=all_tds[<span class="number">3</span>].text</span><br><span class="line">         #体重</span><br><span class="line">         star[<span class="string">"weight"</span>]= all_tds[<span class="number">4</span>].text</span><br><span class="line"></span><br><span class="line">         #花语,去除掉花语中的单引号或双引号</span><br><span class="line">         flower_word = all_tds[<span class="number">5</span>].text</span><br><span class="line">         <span class="keyword">for</span> c in flower_word:</span><br><span class="line">             <span class="keyword">if</span>  c in error_list:</span><br><span class="line">                 flower_word=flower_word.replace(c,<span class="string">''</span>)</span><br><span class="line">         star[<span class="string">"flower_word"</span>]=flower_word </span><br><span class="line">         </span><br><span class="line">         #公司</span><br><span class="line">         <span class="keyword">if</span> not all_tds[<span class="number">6</span>].find(<span class="string">'a'</span>) is  None:</span><br><span class="line">             star[<span class="string">"company"</span>]= all_tds[<span class="number">6</span>].find(<span class="string">'a'</span>).text</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             star[<span class="string">"company"</span>]= all_tds[<span class="number">6</span>].text  </span><br><span class="line"></span><br><span class="line">         stars.append(star)</span><br><span class="line"></span><br><span class="line">    json_data = json.loads(str(stars).replace(<span class="string">"\'"</span>,<span class="string">"\""</span>))   </span><br><span class="line">    <span class="function">with <span class="title">open</span><span class="params">(<span class="string">'work/'</span> + today + <span class="string">'.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'UTF-8'</span>)</span> as f:</span></span><br><span class="line"><span class="function">        json.<span class="title">dump</span><span class="params">(json_data, f, ensure_ascii=False)</span></span></span><br></pre></td></tr></table></figure>

<p>   <strong>三. 爬取每个选手的百度百科图片，并进行保存</strong></p>
<h1 id="三-爬取每个选手的百度百科图片，并进行保存"><a href="#三-爬取每个选手的百度百科图片，并进行保存" class="headerlink" title="三. 爬取每个选手的百度百科图片，并进行保存"></a>三. 爬取每个选手的百度百科图片，并进行保存</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">crawl_pic_urls</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    爬取每个选手的百度百科图片，并保存</span></span><br><span class="line"><span class="function">    ''' </span></span><br><span class="line"><span class="function">    with <span class="title">open</span><span class="params">(<span class="string">'work/'</span>+ today + <span class="string">'.json'</span>, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>)</span> as file:</span></span><br><span class="line"><span class="function">         json_array </span>= json.loads(file.read())</span><br><span class="line"></span><br><span class="line">    headers = &#123; </span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'</span> </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> star in json_array:</span><br><span class="line"></span><br><span class="line">        name = star[<span class="string">'name'</span>]</span><br><span class="line">        link = star[<span class="string">'link'</span>]</span><br><span class="line"></span><br><span class="line">        #向选手的个人百科发送一个http get 请求   </span><br><span class="line">        response = requests.get(link,headers = headers)</span><br><span class="line"></span><br><span class="line">        #获取文档对象</span><br><span class="line">        bs = BeautifulSoup(response.text,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">        #从选手百科页面中解析链接，该链接指向选手图片列表页面</span><br><span class="line">        pic_list_url = bs.select(<span class="string">'.summary-pic a'</span>)[<span class="number">0</span>].get(<span class="string">'href'</span>)</span><br><span class="line">        pic_list_urls = <span class="string">'https://baike.baidu.com'</span> + pic_list_url</span><br><span class="line"></span><br><span class="line">        #获取选手的http</span><br><span class="line">        pic_list_response = requests.get(pic_list_urls,headers = headers)</span><br><span class="line"></span><br><span class="line">        #对选手图片列表进行解析，获取所有图片链接</span><br><span class="line">        bs = BeautifulSoup(pic_list_response.text,<span class="string">'lxml'</span>)</span><br><span class="line">        pic_list_html = bs.select(<span class="string">'.pic-list img '</span>)</span><br><span class="line"></span><br><span class="line">        #定义图片链接存放列表</span><br><span class="line">        pic_urls = []</span><br><span class="line"></span><br><span class="line">        #获取对应的图片链接并保存在pic_urls中</span><br><span class="line">        <span class="keyword">for</span> pic_html in pic_list_html:</span><br><span class="line">            pic_url = pic_html.get(<span class="string">'src'</span>)</span><br><span class="line">            pic_urls.append(pic_url)</span><br><span class="line">            </span><br><span class="line">        #！！！根据图片链接列表pic_urls, 下载所有图片，保存在以name命名的文件夹中！！！</span><br><span class="line">        down_pic(name,pic_urls)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">down_pic</span><span class="params">(name,pic_urls)</span>:</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    根据图片链接列表pic_urls, 下载所有图片，保存在以name命名的文件夹中,</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    path </span>= <span class="string">'work/'</span>+<span class="string">'pics/'</span>+name+<span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> not os.path.exists(path):</span><br><span class="line">      os.makedirs(path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, <span class="function">pic_url in <span class="title">enumerate</span><span class="params">(pic_urls)</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">try</span>:</span></span><br><span class="line"><span class="function">            pic </span>= requests.get(pic_url, timeout=<span class="number">15</span>)</span><br><span class="line">            string = str(i + <span class="number">1</span>) + <span class="string">'.jpg'</span></span><br><span class="line">            <span class="function">with <span class="title">open</span><span class="params">(path+string, <span class="string">'wb'</span>)</span> as f:</span></span><br><span class="line"><span class="function">                f.<span class="title">write</span><span class="params">(pic.content)</span></span></span><br><span class="line"><span class="function">                <span class="title">print</span><span class="params">(<span class="string">'成功下载第%s张图片: %s'</span> % (str(i + <span class="number">1</span>)</span>, <span class="title">str</span><span class="params">(pic_url)</span>))</span></span><br><span class="line"><span class="function">        except Exception as e:</span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(<span class="string">'下载第%s张图片时失败: %s'</span> % (str(i + <span class="number">1</span>)</span>, <span class="title">str</span><span class="params">(pic_url)</span>))</span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(e)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">continue</span></span></span><br></pre></td></tr></table></figure>

<h1 id="四-打印爬取的所有图片的路径"><a href="#四-打印爬取的所有图片的路径" class="headerlink" title="四.打印爬取的所有图片的路径"></a>四.打印爬取的所有图片的路径</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">show_pic_path</span><span class="params">(path)</span>:</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    遍历所爬取的每张图片，并打印所有图片的绝对路径</span></span><br><span class="line"><span class="function">    '''</span></span><br><span class="line"><span class="function">    pic_num </span>= <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (dirpath,dirnames,filenames) in os.walk(path):</span><br><span class="line">        <span class="keyword">for</span> filename in filenames:</span><br><span class="line">           pic_num += <span class="number">1</span></span><br><span class="line">           print(<span class="string">"第%d张照片：%s"</span> % (pic_num,os.path.join(dirpath,filename)))           </span><br><span class="line">    print(<span class="string">"共爬取《青春有你2》选手的%d照片"</span> % pic_num)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">     #爬取百度百科中《青春有你2》中参赛选手信息，返回html</span><br><span class="line">     html = crawl_wiki_data()</span><br><span class="line"></span><br><span class="line">     #解析html,得到选手信息，保存为json文件</span><br><span class="line">     parse_wiki_data(html)</span><br><span class="line"></span><br><span class="line">     #从每个选手的百度百科页面上爬取图片,并保存</span><br><span class="line">     crawl_pic_urls()</span><br><span class="line"></span><br><span class="line">     #打印所爬取的选手图片路径</span><br><span class="line">     show_pic_path(<span class="string">'/home/aistudio/work/pics/'</span>)</span><br><span class="line"></span><br><span class="line">     print(<span class="string">"所有信息爬取完成！"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>青春有你可视化</title>
    <url>/2020/05/03/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A0%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p><strong>对爬取的青春有你2参赛选手的信息进行数据可视化</strong></p>
<h1 id="一-绘制选手区域分布柱状图"><a href="#一-绘制选手区域分布柱状图" class="headerlink" title="一. 绘制选手区域分布柱状图"></a>一. 绘制选手区域分布柱状图</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"><span class="keyword">import</span> numpy as np </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager as font_manager</span><br><span class="line"></span><br><span class="line">#显示matplotlib生成的图形</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="function">with <span class="title">open</span><span class="params">(<span class="string">'data/data31557/20200422.json'</span>, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>)</span> as file:</span></span><br><span class="line"><span class="function">         json_array </span>= json.loads(file.read())</span><br><span class="line"></span><br><span class="line">#绘制小姐姐区域分布柱状图,x轴为地区，y轴为该区域的小姐姐数量</span><br><span class="line"></span><br><span class="line">zones = []</span><br><span class="line"><span class="keyword">for</span> star in json_array:</span><br><span class="line">    zone = star[<span class="string">'zone'</span>]</span><br><span class="line">    zones.append(zone)</span><br><span class="line">print(len(zones))</span><br><span class="line">print(zones)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zone_list = []</span><br><span class="line">count_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> zone in zones:</span><br><span class="line">    <span class="keyword">if</span> zone not in zone_list:</span><br><span class="line">        count = zones.count(zone)</span><br><span class="line">        zone_list.append(zone)</span><br><span class="line">        count_list.append(count)</span><br><span class="line"></span><br><span class="line">print(zone_list)</span><br><span class="line">print(count_list)</span><br><span class="line"></span><br><span class="line"># 设置显示中文</span><br><span class="line">plt.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line"></span><br><span class="line">plt.bar(range(len(count_list)), count_list,color=<span class="string">'r'</span>,tick_label=zone_list,facecolor=<span class="string">'#9999ff'</span>,edgecolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line"># 这里是调节横坐标的倾斜度，rotation是度数，以及设置刻度字体大小</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.yticks(fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">''</span><span class="string">'《青春有你2》参赛选手'</span><span class="string">''</span>,fontsize = <span class="number">24</span>)</span><br><span class="line">plt.savefig(<span class="string">'/home/aistudio/work/result/bar_result.jpg'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"><span class="keyword">import</span> numpy as np </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager as font_manager</span><br><span class="line"><span class="keyword">import</span> pandas as pd</span><br><span class="line"></span><br><span class="line">#显示matplotlib生成的图形</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = pd.read_json(<span class="string">'data/data31557/20200422.json'</span>)</span><br><span class="line">#print(df)</span><br><span class="line"></span><br><span class="line">grouped=df[<span class="string">'name'</span>].groupby(df[<span class="string">'zone'</span>])</span><br><span class="line">s = grouped.count()</span><br><span class="line"></span><br><span class="line">zone_list = s.index</span><br><span class="line">count_list = s.values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置显示中文</span><br><span class="line">plt.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line"></span><br><span class="line">plt.bar(range(len(count_list)), count_list,color=<span class="string">'r'</span>,tick_label=zone_list,facecolor=<span class="string">'#9999ff'</span>,edgecolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line"># 这里是调节横坐标的倾斜度，rotation是度数，以及设置刻度字体大小</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.yticks(fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">''</span><span class="string">'《青春有你2》参赛选手'</span><span class="string">''</span>,fontsize = <span class="number">24</span>)</span><br><span class="line">plt.savefig(<span class="string">'/home/aistudio/work/result/bar_result02.jpg'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h1 id="二-绘制饼状图"><a href="#二-绘制饼状图" class="headerlink" title="二. 绘制饼状图"></a>二. 绘制饼状图</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"><span class="keyword">import</span> numpy as np </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager as font_manager</span><br><span class="line"></span><br><span class="line">#显示matplotlib生成的图形</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">df = pd.read_json(<span class="string">'data/data31557/20200422.json'</span>)</span><br><span class="line"></span><br><span class="line">weights = df[<span class="string">'weight'</span>]</span><br><span class="line">arrs = weights.values</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(len(arrs)</span>):</span></span><br><span class="line"><span class="function">    arrs[i] </span>= <span class="keyword">float</span>(arrs[i] [<span class="number">0</span>:-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">bin = [<span class="number">0</span>,<span class="number">45</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">100</span>]</span><br><span class="line">sel = pd.cut(arrs,bin)</span><br><span class="line"></span><br><span class="line">#pandas的value_counts()函数可以对series里面的每个值进行计数并且排序</span><br><span class="line">pd.value_counts(sel)</span><br><span class="line"></span><br><span class="line">labels = <span class="string">'&lt;= 45kg'</span>,<span class="string">'45~50kg'</span>,<span class="string">'50~55kg'</span>,<span class="string">'&gt;55kg'</span></span><br><span class="line">sizes = pd.value_counts(sel)</span><br><span class="line">explode = (<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fig1,ax1 = plt.subplots()</span><br><span class="line">ax1.pie(sizes,explode = explode, labels = labels, autopct = <span class="string">'%1.1f%%'</span>,shadow = True,startangle = <span class="number">90</span>)</span><br><span class="line">ax1.axis(<span class="string">'equal'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">"best"</span>)</span><br><span class="line">plt.title(<span class="string">''</span><span class="string">'《青春有你2》参赛选手'</span><span class="string">''</span>,fontsize = <span class="number">24</span>)</span><br><span class="line">plt.savefig(<span class="string">'/home/aistudio/work/result/pie_result.jpg'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"><span class="keyword">import</span> numpy as np </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager as font_manager</span><br><span class="line"></span><br><span class="line">#显示matplotlib生成的图形</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">df = pd.read_json(<span class="string">'data/data31557/20200422.json'</span>)</span><br><span class="line"></span><br><span class="line">weights = df[<span class="string">'weight'</span>]</span><br><span class="line">arrs = weights.values</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(len(arrs)</span>):</span></span><br><span class="line"><span class="function">    arrs[i] </span>= <span class="keyword">float</span>(arrs[i] [<span class="number">0</span>:-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">bin = [<span class="number">0</span>,<span class="number">45</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">100</span>]</span><br><span class="line">sel = pd.cut(arrs,bin)</span><br><span class="line"></span><br><span class="line">#pandas的value_counts()函数可以对series里面的每个值进行计数并且排序</span><br><span class="line">pd.value_counts(sel)</span><br><span class="line"></span><br><span class="line">labels = <span class="string">'&lt;= 45kg'</span>,<span class="string">'45~50kg'</span>,<span class="string">'50~55kg'</span>,<span class="string">'&gt;55kg'</span></span><br><span class="line">sizes = pd.value_counts(sel)</span><br><span class="line">explode = (<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fig1,ax1 = plt.subplots()</span><br><span class="line">ax1.pie(sizes,explode = explode, labels = labels, autopct = <span class="string">'%1.1f%%'</span>,shadow = True,startangle = <span class="number">90</span>)</span><br><span class="line">ax1.axis(<span class="string">'equal'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">"best"</span>)</span><br><span class="line">plt.title(<span class="string">''</span><span class="string">'《青春有你2》参赛选手'</span><span class="string">''</span>,fontsize = <span class="number">24</span>)</span><br><span class="line">plt.savefig(<span class="string">'/home/aistudio/work/result/pie_result.jpg'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/03/%E9%9D%92%E6%98%A5%E6%9C%89%E4%BD%A0%E5%8F%AF%E8%A7%86%E5%8C%96/image-20200503230719831.png" alt="image-20200503230719831"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>python 可视化</tag>
      </tags>
  </entry>
</search>
